package NexT.data;

import NexT.Commons;
import java.lang.reflect.Field;
import java.util.logging.Level;

/**
 * Configuration mapper class for easy config handling.
 * @author Shinmera
 * @license GPLv3
 * @version 0.0.0
 */
public abstract class ConfigLoader {
    private DObject loaded;
    
    public ConfigLoader(){}
    
    /**
     * This cannot possibly be allowed to work, as the load bugs out. It HAS
     * to be called after the constructor.
     * @param configblock Noop.
     * @exception Is always thrown to lead ignorant programmers.
     */
    @Deprecated
    public ConfigLoader(DObject configblock){
        throw new IllegalArgumentException("Using load in the constructor is bugged! Call it after initialization instead!");
    }
    
    /**
     * Attempts to load the DObject into this object by using reflection. Fields
     * that have a @noload annotation will not be loaded.
     * @param configblock The configuration to map.
     * @see noload
     */
    public void load(DObject configblock){
        if(configblock == null) throw new IllegalArgumentException("Configblock cannot be null!");
        
        Class c = this.getClass();
        Field[] fields = c.getDeclaredFields();
        for(Field field : fields){
            if(!field.isAnnotationPresent(noload.class)){
                field.setAccessible(true);
                if(configblock.contains(field.getName())){
                    try{
                        DObject dat = configblock.get(field.getName());
                        switch(dat.getType()){
                            case DObject.TYPE_BOOLEAN: field.setBoolean(this, (Boolean)dat.get());break;
                            case DObject.TYPE_DOUBLE:  field.setDouble(this, (Double)dat.get());break;
                            case DObject.TYPE_INTEGER: field.setInt(this, (Integer)dat.get());break;
                            case DObject.TYPE_LONG:    field.setLong(this, (Long)dat.get());break;
                            case DObject.TYPE_STRING:  field.set(this, (String)dat.get());break;
                            case DObject.TYPE_OBJECT:  field.set(this, (DObject)dat);break;
                            case DObject.TYPE_NULL:    field.set(this, null);break;
                        }
                    }catch(IllegalAccessException ex){
                        Commons.log.log(Level.WARNING, toString()+" Failed to set field "+field.getName()+" to '"+configblock.get(field.getName()).get()+"'", ex);
                    }
                }else if(field.isAnnotationPresent(required.class)){
                    throw new IllegalArgumentException("Field '"+field.getName()+"' is marked as required, but not set.");
                }else{
                    try{
                        if(field.get(this) == null)
                            Commons.log.log(Level.WARNING, toString()+" Field "+field.getName()+" has no value!");
                    }catch(IllegalAccessException ex){
                        Commons.log.log(Level.WARNING, toString()+" Failed to check field "+field.getName());
                    }
                }
            }
        }
        loaded = configblock;
    }
    
    /**
     * Saves the internal configuration to the last loaded DObject.
     * @return The modified configblock.
     * @see ConfigLoader#save(NexT.data.DObject) 
     * @see ConfigLoader#load(NexT.data.DObject) 
     */
    public DObject save(){return save(loaded);}
    
    /**
     * Saves the internal configuration to the specified DObject. New fields may
     * be generated by this. Fields that have a @nosave annotation will not be
     * saved.
     * @param configblock The configuration to save to.
     * @return The modified configblock.
     * @see nosave
     */
    public DObject save(DObject configblock){
        Class c = this.getClass();
        Field[] fields = c.getFields();
        for(Field field : fields){
            if(!field.isAnnotationPresent(nosave.class)){
                field.setAccessible(true);
                try{
                    configblock.set(field.getName(), field.get(this));
                }catch(IllegalAccessException ex){
                    Commons.log.log(Level.WARNING, toString()+" Failed to get field "+field.getName());
                }
            }
        }
        return configblock;
    }
    
    public String toString(){return "-ConfigLoader-";}
}
